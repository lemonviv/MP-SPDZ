# coding: latin-1
"""
  Provide logistic function MPC computation for falcon project

  Specifically, this program does in three steps:
  (1) First, keep waiting enough clients (equals to party_num) connected to this program.
  (2) Second, once enough clients connected, read the input values and compute the logistic function.
  (3) Third, return the gfp results (in the secret shared form) to the clients.

  Need to set the following parameters before running:
  (1) ARRAY_SIZE: equals to batch size in the falcon project;
  (2) MAX_NUM_CLIENTS: equals to party number in the falcon project;
  (3) FIXED_F: must be consistent with the SPDZ_PRECISION in the falcon project;
  (4) PORT_NUM: equals to the SPDZ_PORT_BASE in the falcon project;

  Note each client connects in a single thread and so is potentially blocked.
  Each round / game will reset and so this runs indefinitiely.
"""

from Compiler.types import sint, regint, Array, MemValue
from Compiler.instructions import listen, acceptclientconnection
from Compiler.library import print_ln, do_while, for_range
from Compiler.util import if_else
from Compiler import mpc_math, floatingpoint
from random import seed, randrange
from Compiler.program import Program
import ml

### set the sfix precisions
FIXED_F = 16
FIXED_K = 31
sfix.set_precision(FIXED_F, FIXED_K)
cfix.set_precision(FIXED_F, FIXED_K)

### set necessary parameters
ARRAY_SIZE = 32
PORT_NUM = 14000
MAX_NUM_CLIENTS = 3
MAX_NBITS = 14
NULL = -2147483648


### Accept client connections
def accept_client():
    client_socket_id = regint()
    acceptclientconnection(client_socket_id, PORT_NUM)
    return client_socket_id


### Receive private input from client_socket_id
def client_input(client_socket_id):
    client_inputs = sint.receive_from_client(ARRAY_SIZE, client_socket_id)
    return client_inputs


### Compute the logistic function given the received secret shares
def logistic_func(client_inputs):
    result = Array(ARRAY_SIZE, sfix)
    temp = Array(1, sfix)
    @for_range(ARRAY_SIZE)
    def _(j):
        temp[0] = 0
        @for_range(MAX_NUM_CLIENTS)
        def inner(i):
            temp[0] = temp[0] + client_inputs[i][j]
        print_ln("The temp[0] is %s", temp[0].reveal())
        result[j] = ml.sigmoid(temp[0])
        print_ln("The result[j] sigmoid function is %s", result[j].reveal())
    return result


def write_result_to_clients(sockets, number_clients, result):
    """
        Send secret share of result to all clients.
        (should split the result array into number_clients shares, and send each share to each client)
    """

    sint_result = Array(ARRAY_SIZE, sint)
    @for_range(ARRAY_SIZE)
    def _(i):
        sint_result[i] = result[i].v
        print_ln('sint_result[%s] = %s', i, sint_result[i].reveal())

    # split sint_result to number_clients parts and send each part to each client
    sint_result_matrix = sint.Matrix(number_clients, ARRAY_SIZE)
    temp_sum = Array(1, sint)
    @for_range(ARRAY_SIZE)
    def outer_loop(j):
        temp_sum[0] = 0
        @for_range(number_clients)
        def inner_loop(i):
            @if_e(i < number_clients - 1)
            def _():
                random_ij = sint.get_random_int(MAX_NBITS)
                temp_sum[0] = temp_sum[0] + random_ij
                sint_result_matrix[i][j] = random_ij
            @else_
            def _():
                sint_result_matrix[i][j] = sint_result[j] - temp_sum[0]

    """
        @for_range(ARRAY_SIZE)
        def _(j):
            @for_range(number_clients)
            def _(i):
                print_ln('sint_result_matrix[%s][%s] = %s', i, j, sint_result_matrix[i][j].reveal())
    """

    print_ln('begin to write shares to each client')
    @for_range(number_clients)
    def loop_body(i):
        # print_ln('socket[%s] = %s', i, sockets[i])
        sint.write_shares_to_socket(sockets[i], sint_result_matrix[i])


def main():
    """
        Listen in a while loop for the falcon clients to join the mpc computation.
        Once maximum number of falcon clients reached, run the computation and return the result.
    """

    # Start listening on a port for falcon client socket connections
    listen(PORT_NUM)
    print_ln('Listening for socket connections on base port %s', PORT_NUM)

    # Do while loop for iteratively logistic function computation
    @do_while
    def computing_loop():
        print_ln('Starting a new iteration.')

        # Clients socket id (integer).
        client_sockets = Array(MAX_NUM_CLIENTS, regint)

        # Number of clients
        number_clients = MemValue(regint(0))

        # Clients secret inputs
        client_values = sfix.Matrix(MAX_NUM_CLIENTS, ARRAY_SIZE)

        # Keep track of received inputs
        seen = Array(MAX_NUM_CLIENTS, regint)
        seen.assign_all(0)

        # step 1: Loop round waiting for each client to connect
        @do_while
        def client_connections():
            client_id = accept_client()
            @if_(client_id >= MAX_NUM_CLIENTS)
            def _():
                print_ln('client id too high')
                crash()
            client_sockets[client_id] = client_id
            seen[client_id] = 1
            return sum(seen) < MAX_NUM_CLIENTS

        # step 2: receive each client's private input
        @for_range(MAX_NUM_CLIENTS)
        def _(client_id):
            inputs = Array(ARRAY_SIZE, sint)
            inputs = client_input(client_id)
            for j in range(ARRAY_SIZE):
                client_values[client_id][j] = sfix._new(inputs[j])

        # step 3: compute the logistic function
        result = sfix.Array(ARRAY_SIZE)
        result = logistic_func(client_values)

        # step 4: write values back to the clients
        write_result_to_clients(client_sockets, MAX_NUM_CLIENTS, result)

        return True

main()